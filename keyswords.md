 A                 | B        | Ex          |
 :---------------: | :------: | :-----------|
 ! | 느낌표 | |
 " | 큰따옴표 | |
 # | 샾 | |
 $ | 달러 기호 | |
 & | 앰퍼선드 | |
 ' | 작은따옴표 | |
 ( | 여는 괄호 | |
 (file) open / close | 열다 / 닫다 | |
 ) | 닫는 괄호 | |
 * | 별표 | | 
 + | 더하기, 덧셈 부호 | |
 , | 쉼표 | |
 - | 빼기, 뺄셈 부호 | | 
 - | 하이픈 | |
 . | 점 | |
 / | 슬래시 | |
 : | 콜론 | |
 ; | 세미콜론 | |
 < | | |
 = | 등호 | |
 > | | |
 ? | 물음표 | |
 @ | 앳 | |
 Autovivification | 자동생성 | (p.63) |
 CPAN author       | CPAN 저자 | |
 Core Modules | 기본모듈 | |
 Distribution Archive | 배포판 저장소 | |
 File handle | 파일 핸들 | |
 Git Repository    | Git 저장소 | |
 Indirection | 간접 (접근/참조) | All that’s required is a bit of indirection.3 First, we have a selection problem, so we use a grep. We don’t want to grep the values themselves but the index for each item: (p.86) |
 Local Machine | | |
 Mock Object | 모의 객체 | |
 Unicode | 유니코드 | |
 [ | 여는 대괄호 | |
 \ | 백슬래시 | |
 \| | 파이프 기호 | |
 ] | 닫는 대괄호 | |
 ^ | 꺽쇠 | |
 _ | 밑줄 | |
 ` | 역따옴표 | |
 accessor          | 접근자 | |
 alias | 별칭, 별칭을 주다 | |
 annonymous array      | 익명 배열 | |
 annonymous subroutine | 익명 서브루틴 | |
 archive           | 저장소, 압축하다 | |
 argument          | 인자 | |
 array | 배열 | |
 arrow operator | 화살표 연산자 | |
 assignment operator | 대입 연산자 | |
 attribute | 속성 | |
 backend | 백엔드 | |
 background | 후면 | |
 backreference | 뒷참조 | |
 bareword | 베어워드(...) | In the olden days, Perl used barewords for programmer-defined filehandle names, and still does for the special filehandles such as STDIN, ARGV, and others. (p.115) |
 base class | 베이스 클래스 | |
 basename | 베이스네임 | |
 binary tree | 이진 트리 | |
 binary | 이진, 바이너리 | |
 bind  | 결합하다 | |
 bless             | 블레스 | |
 blessed reference | 블레스된 레퍼런스 | |
 boilerplate | 상용구 | |
 byte-order | 바이트 순서 | The binary format used by Storable is architecture byte-order dependent by default, but instead of using store, we used nstore, where the n stands for “network order.” (p.80) |
 cache | 캐시 | |
 character | 문자 | |
 closure | 클로저 | | 
 coderef | 코드 레퍼런스 | So far, we’ve shown references to three main Perl data types: scalars, arrays, and hashes. We can also take a reference to a subroutine (sometimes called a coderef). (p.91) |
 command line      | 명령 행 | |
 command line switch | 명령 행 스위치 | |
 comment out | 주석처리하다 | |
 comment | 주석 | |
 constructor | 생성자 | |
 context           | 컨텍스트 | |
 count | 세다 | |
 counter | 카운터, 계수기 | |
 customize | 맞추다 | |
 daemon | 데몬 | | 
 data type | 데이터 형 | |
 deallocation | 할당해제 | |
 decode | 복호화하다 | |
 deep copy | 깊은 복사 | |
 dereference       | 디레퍼런스 | |
 dereference | 디레퍼런스 | |
 destructor | 소멸자 | |
 directive | 지시자 | |
 directory | 디렉터리 | |
 distribution      | 배포판 | |
 double quote | 큰따옴표 | |
 email | 이메일 | |
 encode | 부호화하다 | |
 entity | 개체 | | 
 entry | 엔트리 | |
 error | 오류, 에러 | |
 escape 하다 | 이스케이프하다 | |
 export            | 익스포트 | |
 expression | (표현)식 | |
 fetch | | |
 file contents | 파일 내용 | |
 file descriptor | 파일 기술자 | |
 file handle | 파일 핸들 | |
 filesystem | 파일 시스템 | |
 flush | 비우다 | |
 foreground | 전면 | |
 fork | 포크 | |
 formatting | 서식, 형식 | |
 function | 함수 | |
 garbage collection | 가비지 컬렉션 | |
 getter            | 획득자 | |
 global variable | 전역변수 | This is true whether the data is held in lexical variables or package global variables. (p.259) |
 handler | 핸들러 | |
 hardcode          | 하드코딩하다 | |
 hash | 해시 | |
 heredoc | 히어 도큐먼트 | |
 hyphen | 하이픈, 붙임표 | |
 immutable         |  | |
 import            | 임포트 | |
 import list | | |
 include file | | | 
 index | 첨자(배열에서), 색인(일반적) | |
 inline subroutine | 인라인 서브루틴 | It’s almost like an inline subroutine. (p.32) |
 interpolation | 보간 | |
 iterator | 반복자 | |
 layer | 계층 | |
 list | 리스트(자료구조) | |
 listen | 리슨 | |
 literal | 리터럴 | That looks odd to us, though, because we had to hardcode the literal string HASH. (p.50) |
 local variable | 로컬 변수 | |
 lock | 락을 걸다, 락 | |
 loop | 루프 | |
 maintainance      | 유지보수 | |
 maintainer        | 유지보수자 | |
 manual | 매뉴얼, 문서(module manual) | | 
 mapping | 대응하다, 대응시키다 | |
 match | 일치 | |
 matching | 일치 검사 | |
 memory allocator | 메모리 할당자 | |
 method | 메소드 | | 
 mixin             | 믹스인 | |
 module | 모듈 | |
 namespace         | 이름공간 | |
 new line | 줄바꿈 | |
 non-block | 논블록 | |
 null | 널 | |
 object            | 객체 | |
 offset | 오프셋 | |
 one line command  | 한 줄짜리 명령문 | |
 override          | 오버라이드 | |
 pack | 묶다 | |
 package manager | 패키지 관리자 | |
 package | 패키지 | |
 parameter         | 매개변수 | |
 parse | 구문해석, 구문/구조을 해석하다 | |
 path tree | 경로 트리 | |
 pattern | 패턴 | |
 permission | 권한 | |
 persistent data | 영속 데이터 | |
 pragma            | 프래그마 | We introduced the strict and warnings pragmas in Learning Perl, and we expect that you’ll use them for all of your code. (p.2) |
 prefix | | |
 prefork | 프리포크 | |
 private variable | 전용 변수 | |
 property | 속성 | |
 query | 질의하다 | |
 quote | 인용처리하다 | |
 random access | 임의 접근 | |
 random | 임의의 | |
 redirect | 리다이렉트 | |
 reference         | 레퍼런스 | |
 reference count | 레퍼런스 카운트 | |
 reference | 레퍼런스 | |
 role              | 롤 | |
 scalar | 스칼라 | |
 schema | 스키마 | |
 scheme | 체계 | |
 schwartzian transform | 슈왈츠 변환 | This construct is commonly called the Schwartzian Transform,5 which was named after Randal (but not by Randal), thanks to a Usenet posting he made many years ago. (p.146) |
 scope | 스코프 | |
 seek offset | 탐색 오프셋 | |
 setter            | 설정자 | |
 shallow copy | 얕은 복사 | This accidentally works because copying named arrays makes a shallow copy. (p.81) |
 shallow copy | 얕은 복사 | |
 signal | 시그널 | |
 single quote | 작은따옴표 | |
 size | 크기 | |
 smartmatching     | 스마트매칭 | |
 spec | 명세 | |
 statement | 구문 | |
 static var | 정적 변수 | |
 stderr | 표준 에러 | |
 stdin | 표준 입력 | |
 stdout | 표준 출력 | |
 stub module | 스텁 모듈 | |
 sub directory     | 하위 디렉토리 | |
 sub-class         | 하위 클래스 | |
 subroutine | 서브루틴 | |
 super-class       | 수퍼 클래스 | | 
 symbol table      | 심볼 테이블  | A typeglob works with the symbol table, which means it’s dealing with package variables. |
 symbolic referenece | 심볼릭 레퍼런스 | Perl tries to use the value 5 as a symbolic reference, so it looks for a filehandle named 5. (p.116) |
 syntax sugar      |  | |
 taint mode | 오염방지 모드 | |
 template | 템플릿 | |
 terminal | 터미널 | |
 test harness | 테스트 하네스 | In that example, we explicitly declared that we’d have one test, and that’s how many test reports the test harness expects our program to report. (p.207) |
 test suite | 테스트 스위트 | |
 tool chain | 툴체인 | |
 trait             | 트레이트 | |
 typeglob | 타입글로브 | We don’t show typeglobs here, but we use the * prefix, which tells Data::Dumper to look at the references to figure out what variable type it should use in the string: (p.79) |
 unarchive | 압축을 푼다 | |
 unlock | 락을 풀다, 언락 | |
 unpack | 풀다 |  |
 user | 사용자 | |
 void context | 보이드 컨텍스트 | |
 weaken reference  |    | |
 whitespace | 공백(문자) | |
 wrap | 래핑하다, 둘러싸다 | | 
 wrapper | 래퍼 | |
 xml element | xml 요소 | |
 { | 여는 중괄호 | |
 } | 닫는 중괄호 | |
 ~ | 물결표 | |
